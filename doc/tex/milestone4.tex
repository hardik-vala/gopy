\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{listings}

\title{Comp 520: Milestone \#4}
\author{The Heapsters: \\Teng Long, Ethan Macdonald, Hardik Vala}
\date{}

\begin{document}

\maketitle

\section{Introduction}

\subsection{Motivation}
We decided to work on a GoLite project for a few key reasons. First of all, we wanted to gain insight into the inner-workings of the languages we most frequently use. Most of these are imperative, general purpose languages like Go. Secondly, we were more interested in the engineering aspects of the compiler than the design of a domain-specific language. Lastly, we felt that the project might have a bit more structure (i.e., more detailed specifications). We believed this be a good thing since all of us were new to writing compilers and were still developing our intuition with regard to the workload created by various design choices (i.e., we did not want too many degrees of freedom).

We used Java with SableCC3 to build the scanner, parser, and abstract syntax tree (AST) since we had some familiarity with SableCC from the first two assignments, and it simplified much of the heavy lifting for the early stages of the compiler. Thereafter, we utilized the generated SableCC code throughout the rest of the compiler (e.g., for traversing the AST during weeding, type checking, and code generation). This allowed us to focus more the design of our compiler rather than the implementation details. For instance, we were able to focus more on having a correct grammar and well-designed AST in lieu of building our own parser, scanner, and AST from scratch. 

\subsection{Contributions}
\subsubsection{Overall}
Although individual contributions did vary from milestone to milestone, the work was pretty evenly distributed between group members over the course of the semester. When possible, we tried to work in the same physical location with one another. This allowed us to bounce ideas off of each other or sort out complicated issues without miscommunication.

\subsubsection{Milestone \#1}
During milestone 1 Ethan and Leo came up with most of the context-free grammar while Hardik modified it to work with SableCC3 and wrote the semicolon insertion rules, Ethan wrote the report, Leo did the pretty printer, and Hardik did most of the AST. 

\subsubsection{Milestone \#2}
During milestone 2, Ethan and Leo worked on the typechecker and tests together. Ethan wrote the weeder. Hardik wrote the pretty printer and report. 

\subsubsection{Milestone \#3}
During milestone 3, Hardik re-did the typechecker (everyone agreed it had to be done), Ethan and Leo started redoing the typechecker but passed the task on to Hardik so as not to duplicate work, and Leo did the first part of the code generator. 

\subsubsection{Milestone \#4}
During milestone 4, everyone worked together to finish up the code generator (especially Leo \& Hardik). Ethan wrote the first draft of this report, and everyone made edits as necessary.


\subsection{Resources}
Aside from SableCC3 and Java, the only resources used were the reference materials and source code referenced in the README.md of our GitHub repository. Below is another list of hyperlinks to those resources.

\subsubsection{Viewed}
\begin{itemize}
\item \href{https://golang.org/ref/spec}{The Go Programming Language Specification}
\item \href{http://www.sable.mcgill.ca/~hendren/520/2016/tiny/}{Tiny language example}
\item \href{https://github.com/leo-teng-long/minipart2/blob/master/src/mini/PrettyPrinter.java}{Leo's MiniLang Pretty Printer}
\item \href{http://www.sable.mcgill.ca/~hendren/520/2016/joos/jjoos-scc-3/}{JOOS SabelCC 3}
\item \href{http://www.sable.mcgill.ca/listarchives/sablecc-list/msg00639.html}{Re: Redefinition Error}
\end{itemize}

\subsubsection{Used}
\begin{itemize}
\item \href{http://www.sable.mcgill.ca/~hendren/520/2016/semicolon-test/}{Example SableCC code for handling GoLite semicolon rule}
\item \href{http://lists.sablecc.org/pipermail/sablecc-discussion/msg00144.html}{Re: SableCC feature suggestion}
\end{itemize}
\section{Compiler Structure}

\subsection{Phase Diagram}

\tikzstyle{RectObject}=[rectangle,draw,inner ysep=.25cm]
\tikzstyle{line}=[draw]
\tikzstyle{arrow}=[draw, -latex] 

\begin{tikzpicture}
\draw(0,0) node[RectObject] (2,1) (Scanner) {Scanner};
\draw(2.1,0) node[RectObject] (4.5,1) (Parser) {Parser};
\draw(4.3,0) node[RectObject] (7,1) (Weeder) {Weeder};
\draw(7,0) node[RectObject] (9.5,1) (Typecheck) {Typechecker};
\draw(10,0) node[RectObject] (12,1) (Generator) {Generator};
\path [arrow]  (Scanner) -- (Parser);
\path [arrow]  (Parser) -- (Weeder);
\path [arrow]  (Weeder) -- (Typecheck);
\path [arrow]  (Typecheck) -- (Generator);

\end{tikzpicture}

\subsection{Scanner \& Parser}

The scanner was a pretty straightforward implementation using SableCC3. We did have a bit of difficulty figuring out the regex for the comments. Our scanner takes in a GoLite program and outputs tokens.

The parser and AST were also fairly straightforward, it just took a long time to agree upon the precise structure that we eventually went with. The biggest challenge was trying to predict which structures would cause issues during later milestones. During later milestones we wound up going back and modifying our grammar/AST somewhat. Our parser takes in tokens and outputs an AST.

We included constraints within our grammar to reduce the amount of weeding required (e.g., we limited the set of allowed top-level statements). Some issues that we chose to defer until later stages included the removal of quotes/backticks from strings, checking proper usage of breaks and continues, checking that fields and array accesses happen on the correct elements, checking for string casts, checking that expressions in simple\_stmt are valid (e.g., function calls), mismatching numbers of ids and values in declaration statements, and distinguishing between function calls and custom type casts.

\subsection{Weeder}

After our milestone 1 was complete we brainstormed a big list of cases that we needed to weed. Later, we thought of a few more weeding conditions while we were working on the typechecker, so we added them. Our weeder takes in an AST and outputs an AST.

Our weeder throws an exception if one of the following occurs:
\begin{itemize}
\item Missing return statement in non-void function (checks all execution paths)
\item Aray in an array access is not non-constant and not a function call
\item Object in a field access is not non-constant and not a function call
\item Type casting for string.
\item Array bound is not an integer
\item Last part of a loop statement is a short assignment
\item Continue statement occurs outside a loop
\item Break statement occurs outside a loop
\item Switch statement contains multiple default cases
\item Decrement is applied to a non-decrementable
\item Increment is applied to a non-incrementable
\item Number of identifiers on the R.H.S. of an assignment, short assignment, or variable specification statement is not equal to the number of expressions on the L.H.S.
\item Number of identifiers on the R.H.S. of a short assignment is not equal to the number of expressions on the L.H.S. or the L.H.S. is a sole blank.
\item Expression statement does not comprise solely of a function call
\end{itemize}

\subsection{Typechecker}

Our first attempt at this section was quite messy. We made some poor design choices early on (e.g., we didn't define our own types, we used a hashmap that pointed to the AST for our symbol table) that we wound up scrapping after the milestone, in favour of re-writing the entire typechecker. This was especially challenging for dealing with aliases, which we never got to work in our original implementation. However, in the second implementation, most of these problems were resolved. Our typechecker takes in an AST and outputs an AST as well as a type/symbol table.

\subsection{Generator}

Python code generation had a few challenges. For example, dynamic scoping was initially a bit of an issue for us, so we decided to go back and alter the names of all of our variables to indicate which scope they were declared in. We also feel like our code runs significantly slower because we chose to handle proper integer overflows, which means we had to make a lot of function calls to force python to behave properly at runtime. Our generator takes in an AST and type/symbol table and outputs python code.

\subsection{Code Generation Justification}
Our compiler writes to python for a few reasons. Python is currently more likely to be on a computer than Go. Additionally, Python is interpreted rather than compiled. We believe this sort of compiler could be useful for languages that have a large compile time but a short run time. Instead of sending the source code to many remote machines, where each of them might need to be compiled individually with a Go compiler, it might be more useful to send code that has been pre-compiled by our compiler so that remote machines can simply run the .py file right away.

We also thought there were some interesting connections between Python and Go: there are significant overlaps between the types of programmers that are attracted to these languages, so it might be useful to have a compiler that allows users to convert from one language to the other. 

Lastly, we were interested in developing a deeper understanding of static vs. duck typing, as well as static vs. dynamic scoping, since we knew we would have to find a way to guarantee congruent runtime behaviour between languages that differ in both these respects.
	
\subsection{Phase Highlights}

\subsubsection{Scanner}
\begin{itemize}
\item Multiline/nested comments issue
\item Semicolon insertion rule was a bit tricky
\end{itemize}
\subsubsection{Parser}
\begin{itemize}
\item Figuring out a sensible context-free grammar
\begin{itemize}
	\item Hardik started working bottom-up, and Leo \& Ethan worked top-down on this until we had the entire CFG defined
\end{itemize}
\item Figuring out a sensible abstract syntax tree
\begin{itemize}
	\item In later parts of our compiler we wound up having extraneous function calls because of how our AST was defined (e.g., node.getOptId().getId() when, in hindsight, it could have been just node.getId()).
	\item Since we're generating Python, it might have been better to have an "elif" statement in our AST, but we didn't realize this until hitting roadblocks during code generation
\end{itemize}
\item For the most part this milestone went smoothly (maybe our design choices didn't bother us until later)
\end{itemize}
\subsubsection{Weeder}
\begin{itemize}
\item Cleaning up cases that we didn't want to handle during parsing (e.g., break/continue statements)
\item This part was pretty fast to implement/went pretty smoothly
\end{itemize}
\subsubsection{Typechecker}
\begin{itemize}
\item Made a bad design decision that we paid for dearly later
	\begin{itemize}
		\item We should have defined our own types
		\item We should have defined a symbol class
		\item We wound up redoing the entire thing with the symbol class and types later
	\end{itemize}
\item Wound up redoing our typechecker with a more sensible design
\item Structs and aliases caused us some grief
	\begin{itemize}
		\item We never did get aliases correct until after we re-did the whole thing
		\item Structs were a bit of a pain because we had chosen an AST representation that was more intuitive for writing the AST than it was for writing the typechecker. However, after wrapping our heads around the problem we were able to work around this inconvenience.
	\end{itemize}
\end{itemize}
\subsubsection{Generator}
\begin{itemize}
\item Dynamic scoping: had to rename all of our variables with their scopes appended to the end so that we were using the right variables for each operation
\item Had to define a function (normalization) that would synthetically cause our integers to overflow. This slowed our programs down a lot but caused correct runtime behaviour.
\item Structs were turned into dicts! Instead of outputting type definitions, we constructed dicts that we inserted into our code when variables were declared. This allowed us to ensure proper runtime behaviour in a language that uses duck typing instead of static typing.
\item Python doesn't have switch statements but we found a way to make them work using if/else statements. TODO: Leo?
\item We used Python while loops in place of Go for loops, because python loops do not map properly to Go for loops (they work more like an iterator than a for loop)
\item Aliasing was a bit of a highlight. TODO: Hardik?
\end{itemize}

\section{Examples}
\lstset{frame=tb,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\ttfamily},
  numbers=none,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}







\subsection{Hello World}
\subsubsection{Notes}
Basic "Hello world!" program.

\subsubsection{GoLite}
\begin{lstlisting}
package main

func main() {
    println("Hello world!")

    print("Hello", " ")
    print("world", "!")
}
\end{lstlisting}
\subsubsection{Python (without normalization)}
\begin{lstlisting}
'''

Presented by [The Heapsters]:

	@the Generator: Long, Teng
	@the PrettyPrinter: Macdonald, Ethan
	@the Stoner: Vala, Hardik

'''

from __future__ import print_function

twoExp31, twoExp32 = 2 ** 31, 2 ** 32
normalize = lambda x : (x + twoExp31) % twoExp32 - twoExp31

true_0, false_0 = True, False

#########################################################
###### The miracle from GoLite to Python2.7 begins ######
#########################################################

def main_1():
	global true_0, false_0
	print("Hello world!")
	print(str("Hello") + str(" "), end = '')
	print(str("world") + str("!"), end = '')

#######################################################
###### The miracle from GoLite to Python2.7 ends ######
#######################################################

if __name__ == '__main__':
	main_1()
\end{lstlisting}
\subsubsection{Python (with normalization)}
\begin{lstlisting}
'''

Presented by [The Heapsters]:

	@the Generator: Long, Teng
	@the PrettyPrinter: Macdonald, Ethan
	@the Stoner: Vala, Hardik

'''

from __future__ import print_function

twoExp31, twoExp32 = 2 ** 31, 2 ** 32
normalize = lambda x : (x + twoExp31) % twoExp32 - twoExp31

true_0, false_0 = True, False

#########################################################
###### The miracle from GoLite to Python2.7 begins ######
#########################################################

def main_1():
	global true_0, false_0
	print("Hello world!")
	print(str("Hello") + str(" "), end = '')
	print(str("world") + str("!"), end = '')

#######################################################
###### The miracle from GoLite to Python2.7 ends ######
#######################################################

if __name__ == '__main__':
	main_1()

\end{lstlisting}






\subsection{Binary Search}

\subsubsection{Notes}
TODO 

\subsubsection{GoLite}

\begin{lstlisting}
package main

var array []int

func binarySearch(array []int, size, target int) int {
    low := 0
    high := size - 1

    for low <= high {
        mid := (low + high) / 2
        
        if (array[mid] < target) {
            low = mid + 1
        } else if (array[mid] > target) {
            high = mid - 1
        } else {
            return mid
        }
    }

    return -1
}

func main() {
    for i := 1; i <= 10; i++ {
        array = append(array, i)
    }

    println("Index of 10:", binarySearch(array, 10, 10))
}

\end{lstlisting}

\subsubsection{Python (without normalization)}

\begin{lstlisting}
'''

Presented by [The Heapsters]:

	@the Generator: Long, Teng
	@the PrettyPrinter: Macdonald, Ethan
	@the Stoner: Vala, Hardik

'''

from __future__ import print_function

twoExp31, twoExp32 = 2 ** 31, 2 ** 32
normalize = lambda x : (x + twoExp31) % twoExp32 - twoExp31

true_0, false_0 = True, False

#########################################################
###### The miracle from GoLite to Python2.7 begins ######
#########################################################

array_1 = []

def binarySearch_1(array_2, size_2, target_2):
	global true_0, false_0, array_1
	low_2 = 0
	high_2 = (size_2 - 1)
	while (low_2 <= high_2):
		mid_4 = ((low_2 + high_2) / 2)
		if (array_2[mid_4] < target_2):
			low_2 = (mid_4 + 1)
		else:
			if (array_2[mid_4] > target_2):
				high_2 = (mid_4 - 1)
			else:
				return mid_4
	return (- 1)

def main_1():
	global true_0, false_0, array_1
	i_3 = 1
	while (i_3 <= 10):
		array_1.append(i_3)
		i_3 = i_3 + 1
	print("Index of 10:", binarySearch_1(array_1, 10, 10))

#######################################################
###### The miracle from GoLite to Python2.7 ends ######
#######################################################

if __name__ == '__main__':
	main_1()
\end{lstlisting}

\subsubsection{Python (with normalization)}
\begin{lstlisting}
'''

Presented by [The Heapsters]:

	@the Generator: Long, Teng
	@the PrettyPrinter: Macdonald, Ethan
	@the Stoner: Vala, Hardik

'''

from __future__ import print_function

twoExp31, twoExp32 = 2 ** 31, 2 ** 32
normalize = lambda x : (x + twoExp31) % twoExp32 - twoExp31

true_0, false_0 = True, False

#########################################################
###### The miracle from GoLite to Python2.7 begins ######
#########################################################

array_1 = []

def binarySearch_1(array_2, size_2, target_2):
	global true_0, false_0, array_1
	low_2 = 0
	high_2 = normalize((normalize(size_2) - 1))
	while (normalize(low_2) <= normalize(high_2)):
		mid_4 = normalize((normalize((normalize(low_2) + normalize(high_2))) / 2))
		if (normalize(array_2[mid_4]) < normalize(target_2)):
			low_2 = normalize((normalize(mid_4) + 1))
		else:
			if (normalize(array_2[mid_4]) > normalize(target_2)):
				high_2 = normalize((normalize(mid_4) - 1))
			else:
				return mid_4
	return (- 1)

def main_1():
	global true_0, false_0, array_1
	i_3 = 1
	while (normalize(i_3) <= 10):
		array_1.append(i_3)
		i_3 = normalize(i_3 + 1)
	print("Index of 10:", normalize(binarySearch_1(array_1, 10, 10)))

#######################################################
###### The miracle from GoLite to Python2.7 ends ######
#######################################################

if __name__ == '__main__':
	main_1()
\end{lstlisting}








\subsection{Bubble Sort}
\subsubsection{Notes}
TODO 

\subsubsection{GoLite}
\begin{lstlisting}
package main

var array []int

func printArray(array []int, size int) {
    for i := 0; i < size; i++ {
        println(array[i])
    }
}

func bubbleSort(array []int, size int)  {
    for i := 0; i < size - 1; i++ {
        swapped := false

        for j := 0; j < size - 1 - i; j++ {
            if array[j] > array[j + 1] {
                temp := array[j]
                array[j] = array[j + 1]
                array[j + 1] = temp
                swapped = true
            }
        }

        if swapped {
            continue
        }
    }
}

func main() {
    for i := 10; i > 0; i-- {
        array = append(array, i)
    }

    println("Before:")
    printArray(array, 10)

    bubbleSort(array, 10)

    println("Sorted:")
    printArray(array, 10)
}
\end{lstlisting}
\subsubsection{Python (without normalization)}
\begin{lstlisting}
\end{lstlisting}
\subsubsection{Python (with normalization)}
\begin{lstlisting}

\end{lstlisting}








\subsection{Weekday Weekend}
\subsubsection{Notes}
TODO 
\subsubsection{GoLite}
\begin{lstlisting}
package main

func foo(day string) {
    switch day {
        case "Monday", "Tuesday", "Wednesday", "Thursday", "Friday":
            println("Weekday")
        case "Saturday", "Sunday":
            println("Weekend")
        default:
            println("Invalid")
    }
}

func main() {
    foo("Saturday")
}
\end{lstlisting}
\subsubsection{Python (without normalization)}
\begin{lstlisting}
'''

Presented by [The Heapsters]:

	@the Generator: Long, Teng
	@the PrettyPrinter: Macdonald, Ethan
	@the Stoner: Vala, Hardik

'''

from __future__ import print_function

twoExp31, twoExp32 = 2 ** 31, 2 ** 32
normalize = lambda x : (x + twoExp31) % twoExp32 - twoExp31

true_0, false_0 = True, False

#########################################################
###### The miracle from GoLite to Python2.7 begins ######
#########################################################

def foo_1(day_2):
	global true_0, false_0
	if (day_2 == "Monday") or (day_2 == "Tuesday") or (day_2 == "Wednesday") or (day_2 == "Thursday") or (day_2 == "Friday"):
		print("Weekday")
	elif (day_2 == "Saturday") or (day_2 == "Sunday"):
		print("Weekend")
	else:
		print("Invalid")

def main_1():
	global true_0, false_0
	foo_1("Saturday")

#######################################################
###### The miracle from GoLite to Python2.7 ends ######
#######################################################

if __name__ == '__main__':
	main_1()
\end{lstlisting}
\subsubsection{Python (with normalization)}
\begin{lstlisting}
'''

Presented by [The Heapsters]:

	@the Generator: Long, Teng
	@the PrettyPrinter: Macdonald, Ethan
	@the Stoner: Vala, Hardik

'''

from __future__ import print_function

twoExp31, twoExp32 = 2 ** 31, 2 ** 32
normalize = lambda x : (x + twoExp31) % twoExp32 - twoExp31

true_0, false_0 = True, False

#########################################################
###### The miracle from GoLite to Python2.7 begins ######
#########################################################

def foo_1(day_2):
	global true_0, false_0
	if (day_2 == "Monday") or (day_2 == "Tuesday") or (day_2 == "Wednesday") or (day_2 == "Thursday") or (day_2 == "Friday"):
		print("Weekday")
	elif (day_2 == "Saturday") or (day_2 == "Sunday"):
		print("Weekend")
	else:
		print("Invalid")

def main_1():
	global true_0, false_0
	foo_1("Saturday")

#######################################################
###### The miracle from GoLite to Python2.7 ends ######
#######################################################

if __name__ == '__main__':
	main_1()
\end{lstlisting}

\section{Conclusion and Future work}

\subsection{Future work}
Data flow analysis.

Our generated code has not been optimized very much, so there is a lot of room for optimization (e.g., peephole optimizer). Additionally, it would be worthwhile to modify our AST somewhat to include "elif" statements (this would simplify our control structures during code generation). There is always room for more tests.

\subsection{Conclusion}

This was fun. We are done.

\end{document}
