\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{tikz}

\title{Comp 520: Milestone \#4}
\author{The Heapsters: \\Teng Long, Ethan Macdonald, Hardik Vala}
\date{}

\begin{document}

\maketitle

\section{Introduction}

\subsection{Motivation}
We decided to work on a GoLite project because we wanted to gain experience writing a compiler for a general purpose language (as opposed to a domain specific language). Additionally, we felt that the project might have a bit more structure (i.e., more detailed specifications). We believed this be a good thing since all of us were new to writing compilers and were still developing our intuition with regard to the workload created by various design choices (i.e., we did not want too many degrees of freedom).

We used SableCC3 to build the scanner, parser, and abstract syntax tree (AST) since we had some familiarity with it from the first two assignments, and it simplified much of the heavy lifting for the early stages of the compiler. This allowed us to focus more on having a correct grammar and well-designed AST in lieu of building our own parser, scanner, and AST from scratch.

\subsection{Contributions}
Although individual contributions did vary from milestone to milestone, the work was pretty evenly distributed between group members over the course of the semester. When possible, we tried to work in the same physical location with one another. This allowed us to bounce ideas off of each other or sort out complicated issues without miscommunication.

During milestone 1 Ethan and Leo came up with most of the context-free grammar while Hardik modified it to work with SableCC3, Ethan wrote the report, Leo did the pretty printer, and Hardik did most of the AST. During milestone 2, Ethan and Leo worked on the typechecker together. Hardik wrote the pretty printer and report. For milestone 3, Hardik re-did the typechecker (everyone agreed it had to be done), Ethan and Leo started redoing the typechecker but passed the task on to Hardik so as not to duplicate work, and Leo did the first part of the code generator. On milestone 4, everyone worked together to finish up the code generator. Ethan wrote the first draft of this report, and everyone made edits as necessary. TODO: pull out details from our old reports


\subsection{Resources}
Aside from SableCC3 and Java, the only resources used were the reference materials and source code referenced in the README.md of our GitHub repository. TODO: These resources

\section{Compiler Structure}

\subsection{Phase Diagram}

\tikzstyle{RectObject}=[rectangle,draw,inner ysep=.25cm]
\tikzstyle{line}=[draw]
\tikzstyle{arrow}=[draw, -latex] 

\begin{tikzpicture}
\draw(0,0) node[RectObject] (2,1) (Scanner) {Scanner};
\draw(2.1,0) node[RectObject] (4.5,1) (Parser) {Parser};
\draw(4.3,0) node[RectObject] (7,1) (Weeder) {Weeder};
\draw(7,0) node[RectObject] (9.5,1) (Typecheck) {Typechecker};
\draw(10,0) node[RectObject] (12,1) (Generator) {Generator};
\path [arrow]  (Scanner) -- (Parser);
\path [arrow]  (Parser) -- (Weeder);
\path [arrow]  (Weeder) -- (Typecheck);
\path [arrow]  (Typecheck) -- (Generator);

\end{tikzpicture}

\subsection{Code Generation Justification}
Our compiler writes to python for a few reasons. Python is currently more likely to be on a computer than Go. Additionally, Python is interpreted rather than compiled. We believe this sort of compiler could be useful for languages that have a large compile time but a short run time. Instead of sending the source code to many remote machines, where each of them might need to be compiled individually with a Go compiler, it might be more useful to send code that has been pre-compiled by our compiler so that remote machines can simply run the .py file right away.

We also thought there were some interesting connections between Python and Go: there are significant overlaps between the types of programmers that are attracted to these languages, so it might be useful to have a compiler that allows users to convert from one language to the other. 

Lastly, we were interested in developing a deeper understanding of static vs. duck typing, as well as static vs. dynamic scoping, since we knew we would have to find a way to guarantee congruent runtime behaviour between languages that differ in both these respects.
	
\subsection{Phase Highlights}

\subsubsection{Scanner}
\begin{itemize}
\item Multiline/nested comments issue
\end{itemize}
\subsubsection{Parser}
\begin{itemize}
\item Figuring out a sensible context-free grammar
\item Figuring out a sensible abstract syntax tree
\item For the most part this milestone went smoothly (maybe our design choices didn't bother us until later)
\end{itemize}
\subsubsection{Weeder}
\begin{itemize}
\item Cleaning up cases that we didn't want to handle during parsing
\end{itemize}
\subsubsection{Typechecker}
\begin{itemize}
\item Made a bad design decision that we paid for dearly later
\item Wound up redoing our typechecker with a more sensible design
\item Structs and aliases caused us some grief
\end{itemize}
\subsubsection{Generator}
\begin{itemize}
\item Dynamic scoping: had to rename all of our variables with their scopes appended to the end so that we were using the right variables for each operation
\item Had to define a function (bit\_mask) that would synthetically cause our integers to overflow. This slowed our programs down a lot but caused correct runtime behaviour.
\item Structs were turned into dicts!
\end{itemize}

\section{Examples}

TODO

\section{Conclusion and Future work}

TODO (at end)

\end{document}
