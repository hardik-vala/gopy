Package golite ;

Helpers
    // All ASCII characters.
    all = [0 .. 127] ;
    
    // Special whitespace characters.
    tab = 9 ;
    lf = 10 ;
    cr = 13 ;

    // All but End-of-line characters.
    not_eol = [all - [cr + lf]] ;

    // All but '*'.
    not_star = [all - '*'] ;
    // All but '*' and '/'.
    not_star_slash = [all - ['*' + '/']] ;

    // Digit.
    digit = ['0' .. '9'] ;
    // Positive (i.e. non-zero) digit.
    pos_digit = ['1' .. '9'] ;
    // Octal digit.
    oct_digit = ['0' .. '7'] ;
    // Hexidecimal digit.
    hex_digit = digit | ['A' .. 'F'] | ['a' .. 'f'] ;

    // Quotes.
    squote = ''' ;
    dquote = '"' ;
    bquote = '`' ;

    // Escaped characters.
    escapes = '\' ('a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\') ;
    escape_squote = '\' ''';
    escape_dquote = '\"';

    // Alphabet characters (plus underscore).
    alpha = ['A' .. 'Z'] | ['a' .. 'z'] | '_' ;
    // Alphanumeric characters (plus underscore).
    alpha_num = alpha | digit ;

Tokens
    //* Go keywords. *//
    break = 'break' ;
    case = 'case' ;
    chan = 'chan' ;
    const = 'const' ;
    continue = 'continue' ;
    default = 'default' ;
    defer = 'defer' ;
    else = 'else' ;
    fallthrough = 'fallthrough' ;
    for = 'for' ;
    func = 'func' ;
    go = 'go' ;
    goto = 'goto' ;
    if = 'if' ;
    import = 'import' ;
    interface = 'interface' ;
    map = 'map' ;
    package = 'package' ;
    range = 'range' ;
    return = 'return' ;
    select = 'select' ;
    struct = 'struct' ;
    switch = 'switch' ;
    type = 'type' ;
    var = 'var' ;

    //* GoLite keywords. *//
    int = 'int' ;
    float64 = 'float64' ;
    bool = 'bool' ;
    rune = 'rune' ;
    string = 'string' ;
    print = 'print' ;
    println = 'println' ;
    append = 'append' ;

    //*  Operators. *//
    // Arithmetic.
    plus = '+' ;
    minus = '-' ;
    star = '*' ;
    slash = '/' ;
    perc = '%' ;
    // Bitwise.
    amp = '&' ;
    pipe = '|' ;
    carot = '^';
    lshift = '<<' ;
    rshift = '>>' ;
    amp_carot = '&^' ;
    // Arithmetic operator assignment.
    plus_assign = '+=' ;
    minus_assign = '-=' ;
    star_assign = '*=' ;
    slash_assign = '/=' ;
    perc_assign = '%=' ;
    // Bitwise operator assignment.
    and_assign = '&=' ;
    pipe_assign = '|=' ;
    carot_assign = '^=' ;
    lshift_assign = '<<=' ;
    rshift_assign = '>>=' ;
    amp_carot_assign = '&^=' ;
    // Logical.
    amp_amp = '&&' ;
    pipe_pipe = '||' ;
    not = '!' ;
    // Receive.
    arrow = '<-' ;
    // Increment.
    plus_plus = '++' ;
    // Decrement.
    minus_minus = '--' ;
    // Comparison
    equals = '==' ;
    not_equals = '!=' ;
    lt = '<' ;
    gt = '>' ;
    lte = '<=' ;
    gte = '>=' ;
    // Assignment.
    assign = '=' ;
    short_assign = ':=' ;
    // Ellipsis (Variadic).
    ellipsis = '...' ;
    // Parentheses.
    lparen = '(' ;
    rparen = ')' ;
    // Square brackets.
    lsquare = '[' ;
    rsquare = ']' ;
    // Braces.
    lbrace = '{' ;
    rbrace = '}' ;
    // Other.
    comma = ',' ;
    semi = ';' ;
    dot = '.' ;
    colon = ':' ;

    // Blank space.
    blank = ' ' | tab ;
    // End-of-line.
    eol = lf | cr | cr lf ;

    // Single-line comment and multi-line comments.
    comment = '//' not_eol* | '/*' ([all - '*'] | '*' [all - '/'])* '*/' ;
    // Alternative form for handling multi-line comments:
    // comment = '//' not_eol* | '/*' '*'* [all - '*']+ '*'+ ([all - ['*' + '/']] [all - '*']* '*'+)* '/' ;

    //* Literals. *//

    // Boolean.
    bool_lit = 'true' | 'false' ;

    // Integer.
    int_lit = '0' | pos_digit digit* ;
    oct_lit = '0' oct_digit+ ;
    hex_lit = '0' ['x' + 'X'] hex_digit+ ;

    // Floating-point.
    float_lit = ('0' | pos_digit digit*)? '.' digit* | '.' digit+ ;

    // Rune.
    rune_lit = squote ([not_eol - [squote + '\']] | escape_squote| escapes) squote ;

    // Interpreted string.
    interpreted_string_lit = dquote ([not_eol - [dquote + '\']] | escape_dquote| escapes)* dquote ;

    // Raw string.
    raw_string_lit = bquote [all - bquote]* bquote ;

    //* Identifiers. *//
    id = alpha alpha_num* ;

Ignored Tokens
    blank, eol, comment ;

Productions
    // TODO: Fix variable naming.

    //* Program. *//
    
    prog {-> prog} = {prog} expr_list {-> New prog.program([expr_list.expr])} ;

    convertible_prim_type {-> type_expr} = 
          {int} int
            {-> New type_expr.int()}
        | {float} float64
            {-> New type_expr.float()}
        | {rune} rune
            {-> New type_expr.rune()} ;

    //* Expressions. *//

    expr_list {-> expr*} =
          {empty_expr}
            {-> []}
        | {expr} expr
            {-> [expr.expr]}
        | {cst_exprs} expr comma expr_list 
            {-> [expr.expr, expr_list.expr]} ;

    expr {-> expr} =
          {conjunction} conjunction
            {-> conjunction.expr}
        | {cst_or}      expr pipe_pipe conjunction 
            {-> New expr.or(expr.expr, conjunction.expr)} ;

    conjunction {-> expr} =
          {clause} clause
            {-> clause.expr}
        | {cst_and} conjunction amp_amp clause 
            {-> New expr.and(conjunction.expr, clause.expr)} ;

    clause {-> expr} =
          {sub_expr} sub_expr
            {-> sub_expr.expr}
        | {cst_eq} clause equals sub_expr
            {-> New expr.eq(clause.expr, sub_expr.expr)}
        | {cst_neq} clause not_equals sub_expr
            {-> New expr.neq(clause.expr, sub_expr.expr)}
        | {cst_lt} clause lt sub_expr
            {-> New expr.lt(clause.expr, sub_expr.expr)}
        | {cst_lte} clause lte sub_expr
            {-> New expr.lte(clause.expr, sub_expr.expr)}
        | {cst_gt} clause gt sub_expr
            {-> New expr.gt(clause.expr, sub_expr.expr)}
        | {cst_gte} clause gte sub_expr 
            {-> New expr.gte(clause.expr, sub_expr.expr)} ;

    sub_expr {-> expr} =
          {factor} factor
            {-> factor.expr}
        | {cst_plus} sub_expr plus factor
            {-> New expr.add(sub_expr.expr, factor.expr)}
        | {cst_minus} sub_expr minus factor
            {-> New expr.subtract(sub_expr.expr, factor.expr)}
        | {cst_bit_or} sub_expr pipe factor
            {-> New expr.bit_or(sub_expr.expr, factor.expr)}
        | {cst_bit_xor} sub_expr carot factor 
            {-> New expr.bit_xor(sub_expr.expr, factor.expr)} ;

    factor {-> expr} =
          {term} term
            {-> term.expr}
        | {cst_mult} factor star term
            {-> New expr.mult(factor.expr, term.expr)}
        | {cst_div} factor slash term
            {-> New expr.div(factor.expr, term.expr)}
        | {cst_mod} factor perc term
            {-> New expr.mod(factor.expr, term.expr)}
        | {cst_lshift} factor lshift term
            {-> New expr.lshift(factor.expr, term.expr)}
        | {cst_rshift} factor rshift term
            {-> New expr.rshift(factor.expr, term.expr)}
        | {cst_bit_and} factor amp term
            {-> New expr.bit_and(factor.expr, term.expr)}
        | {cst_bit_clear} factor amp_carot term 
            {-> New expr.bit_clear(factor.expr, term.expr)} ;

    term {-> expr} =
          {atom} atom
            {-> atom.expr}
        | {cst_pos} plus atom
            {-> New expr.unary_pos(atom.expr)}
        | {cst_neg} minus atom
            {-> New expr.unary_neg(atom.expr)}
        | {cst_not} not atom
            {-> New expr.unary_not(atom.expr)}
        | {cst_bit_comp} carot atom 
            {-> New expr.unary_bit_comp(atom.expr)} ;

    atom {-> expr} =
          {lit} lit
            {-> lit.expr}
        | {id} id
            {-> New expr.id(id)} 
        | {field} atom dot id
            {-> New expr.field(atom.expr, id)}
        | {func_call} func_call
            {-> func_call.expr}
        | {paren} lparen expr rparen 
           {-> expr.expr};

    func_call {-> expr} = 
          {append} append lparen id comma expr rparen
            {-> New expr.append(id, expr)}
        | {prim_type_cast} convertible_prim_type lparen expr rparen
            {-> New expr.prim_type_cast(convertible_prim_type.type_expr, expr)}
        | {custom_func_call} id lparen expr_list rparen
            {-> New expr.func_call(id, [expr_list.expr])};

    lit {-> expr} =
      {bool_lit} bool_lit 
        {-> New expr.bool_lit(bool_lit)}
    | {int_lit} int_lit 
        {-> New expr.int_lit(int_lit)}
    | {oct_lit} oct_lit 
        {-> New expr.oct_lit(oct_lit)}
    | {hex_lit} hex_lit 
        {-> New expr.hex_lit(hex_lit)}
    | {float_lit} float_lit 
        {-> New expr.float_lit(float_lit)}
    | {rune_lit} rune_lit 
        {-> New expr.rune_lit(rune_lit)}
    | {interpreted_string_lit} interpreted_string_lit 
        {-> New expr.interpreted_string_lit(interpreted_string_lit)}
    | {raw_string_lit} raw_string_lit 
        {-> New expr.raw_string_lit(raw_string_lit)};

Abstract Syntax Tree
    prog = 
        {program}  expr* ;

    type_expr =
          {int}
        | {float}
        | {rune} ;

    expr =  
          {bool_lit} bool_lit
        | {int_lit} int_lit
        | {oct_lit} oct_lit
        | {hex_lit} hex_lit 
        | {float_lit} float_lit
        | {rune_lit} rune_lit 
        | {interpreted_string_lit} interpreted_string_lit 
        | {raw_string_lit} raw_string_lit
        | {id} id
        | {field} [object]:expr [property]:id
        | {append} id expr
        | {prim_type_cast} type_expr expr
        | {func_call} id expr*

        | {unary_neg} expr
        | {unary_pos} expr
        | {unary_bit_comp} expr
        | {unary_not} expr 
        | {mult} [left]:expr [right]:expr
        | {div} [left]:expr [right]:expr
        | {mod} [left]:expr [right]:expr
        | {lshift} [left]:expr [right]:expr
        | {rshift} [left]:expr [right]:expr
        | {bit_and} [left]:expr [right]:expr
        | {bit_clear} [left]:expr [right]:expr 
        | {add} [left]:expr [right]:expr
        | {subtract} [left]:expr [right]:expr
        | {bit_or} [left]:expr [right]:expr
        | {bit_xor} [left]:expr [right]:expr 
        | {eq} [left]:expr [right]:expr
        | {neq} [left]:expr [right]:expr
        | {lt} [left]:expr [right]:expr
        | {gt} [left]:expr [right]:expr
        | {lte} [left]:expr [right]:expr
        | {gte} [left]:expr [right]:expr 
        | {and} [left]:expr [right]:expr
        | {or} [left]:expr [right]:expr ;
