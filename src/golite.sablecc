Package golite ;

Helpers
    // All ASCII characters.
    all = [0 .. 127] ;
    
    // Special whitespace characters.
    tab = 9 ;
    lf = 10 ;
    cr = 13 ;

    // All but End-of-line characters.
    not_eol = [all - [cr + lf]] ;

    // All but '*'.
    not_star = [all - '*'] ;
    // All but '*' and '/'.
    not_star_slash = [all - ['*' + '/']] ;

    // Digit.
    digit = ['0' .. '9'] ;
    // Positive (i.e. non-zero) digit.
    pos_digit = ['1' .. '9'] ;
    // Octal digit.
    oct_digit = ['0' .. '7'] ;
    // Hexidecimal digit.
    hex_digit = digit | ['A' .. 'F'] | ['a' .. 'f'] ;

    // Quotes.
    squote = ''' ;
    dquote = '"' ;
    bquote = '`' ;

    // Escaped characters.
    escapes = '\' ('a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\') ;
    escape_squote = '\' ''';
    escape_dquote = '\"';

    // Alphabet characters (plus underscore).
    alpha = ['A' .. 'Z'] | ['a' .. 'z'] | '_' ;
    // Alphanumeric characters (plus underscore).
    alpha_num = alpha | digit ;

Tokens
    //* Go keywords. *//
    break = 'break' ;
    case = 'case' ;
    chan = 'chan' ;
    const = 'const' ;
    continue = 'continue' ;
    default = 'default' ;
    defer = 'defer' ;
    else = 'else' ;
    fallthrough = 'fallthrough' ;
    for = 'for' ;
    func = 'func' ;
    go = 'go' ;
    goto = 'goto' ;
    if = 'if' ;
    import = 'import' ;
    interface = 'interface' ;
    map = 'map' ;
    package = 'package' ;
    range = 'range' ;
    return = 'return' ;
    select = 'select' ;
    struct = 'struct' ;
    switch = 'switch' ;
    type = 'type' ;
    var = 'var' ;

    //* GoLite keywords. *//
    int = 'int' ;
    float64 = 'float64' ;
    bool = 'bool' ;
    rune = 'rune' ;
    string = 'string' ;
    print = 'print' ;
    println = 'println' ;
    append = 'append' ;

    //*  Operators. *//
    // Arithmetic.
    plus = '+' ;
    minus = '-' ;
    star = '*' ;
    slash = '/' ;
    perc = '%' ;
    // Bitwise.
    amp = '&' ;
    pipe = '|' ;
    carot = '^';
    lshift = '<<' ;
    rshift = '>>' ;
    amp_carot = '&^' ;
    // Arithmetic operator assignment.
    plus_assign = '+=' ;
    minus_assign = '-=' ;
    star_assign = '*=' ;
    slash_assign = '/=' ;
    perc_assign = '%=' ;
    // Bitwise operator assignment.
    and_assign = '&=' ;
    pipe_assign = '|=' ;
    carot_assign = '^=' ;
    lshift_assign = '<<=' ;
    rshift_assign = '>>=' ;
    amp_carot_assign = '&^=' ;
    // Logical.
    amp_amp = '&&' ;
    pipe_pipe = '||' ;
    not = '!' ;
    // Receive.
    arrow = '<-' ;
    // Increment.
    plus_plus = '++' ;
    // Decrement.
    minus_minus = '--' ;
    // Comparison
    equals = '==' ;
    not_equals = '!=' ;
    lt = '<' ;
    gt = '>' ;
    lte = '<=' ;
    gte = '>=' ;
    // Assignment.
    assign = '=' ;
    short_assign = ':=' ;
    // Ellipsis (Variadic).
    ellipsis = '...' ;
    // Parentheses.
    lparen = '(' ;
    rparen = ')' ;
    // Square brackets.
    lsquare = '[' ;
    rsquare = ']' ;
    // Braces.
    lbrace = '{' ;
    rbrace = '}' ;
    // Other.
    comma = ',' ;
    semi = ';' ;
    dot = '.' ;
    colon = ':' ;

    // Blank space.
    blank = ' ' | tab ;
    // End-of-line.
    eol = lf | cr | cr lf ;

    // Single-line comment and multi-line comments.
    comment = '//' not_eol* | '/*' ([all - '*'] | '*' [all - '/'])* '*/' ;
    // Alternative form for handling multi-line comments:
    // comment = '//' not_eol* | '/*' '*'* [all - '*']+ '*'+ ([all - ['*' + '/']] [all - '*']* '*'+)* '/' ;

    //* Literals. *//

    // Boolean.
    bool_lit = 'true' | 'false' ;

    // Integer.
    int_lit = '0' | pos_digit digit* ;
    oct_lit = '0' oct_digit+ ;
    hex_lit = '0' ['x' + 'X'] hex_digit+ ;

    // Floating-point.
    float_lit = ('0' | pos_digit digit*)? '.' digit* | '.' digit+ ;

    // Rune.
    rune_lit = squote ([not_eol - [squote + '\']] | escape_squote| escapes) squote ;

    // Interpreted string.
    interpreted_string_lit = dquote ([not_eol - [dquote + '\']] | escape_dquote| escapes)* dquote ;

    // Raw string.
    raw_string_lit = bquote [all - bquote]* bquote ;

    //* Identifiers. *//
    id = alpha alpha_num* ;

Ignored Tokens
    blank, eol, comment ;

Productions
    //* Program. *//
    
    prog {-> prog} = pack_dec expr_list {-> New prog.prog(pack_dec.id, [expr_list.expr])} ;

    //* Package declaration. *//

    pack_dec {-> id} = package id semi {-> id};

    //* Top-level declaration. *//

    top_dec {-> top_dec} =
          {var_dec} var_dec
            {-> var_dec.top_dec}
        | {type_dec} type_dec
            {-> type_dec.top_dec} ;
        /* | {func_dec} func_dec ; */

    //* Variable declaration. *//

    var_dec {-> top_dec} =
          {sing} var var_spec semi
            {-> New top_dec.vars([var_spec])}
        | {dist} var lparen var_spec_stmt* rparen semi
            {-> New top_dec.vars([var_spec_stmt.var_spec])} ;

    var_spec_stmt {-> var_spec} = var_spec semi {-> var_spec} ;

    var_spec {-> var_spec} =
          {typed} id_list type_expr
            {-> New var_spec.spec([id_list.id], type_expr, [])}
        | {init} id_list assign expr_list
            {-> New var_spec.spec([id_list.id], Null, [expr_list.expr])}
        | {typed_init} id_list type_expr assign expr_list
            {-> New var_spec.spec([id_list.id], type_expr, [expr_list.expr])};

    //* Type declaration. *//

    type_dec {-> top_dec} =
          {sing} type type_spec semi
            {-> New top_dec.types([type_spec])}
        | {dist} type lparen type_spec_stmt* rparen semi
            {-> New top_dec.types([type_spec_stmt.type_spec])} ;

    type_spec_stmt {-> type_spec} = type_spec semi {-> type_spec} ;

    type_spec {-> type_spec} = id type_expr {-> New type_spec.spec([id], type_expr)} ;

    //* Identifiers *//

    id_list {-> id*} =
          {id} id
            {-> [id]}
        | {ids} id comma id_list
            {-> [id, id_list.id]} ;

    //* Types *//

    type_expr {-> type_expr} =
          {prim_type} prim_type
            {-> prim_type.type_expr}
        | {custom_type} id
            {-> New type_expr.custom(id)}
        | {array} lsquare expr rsquare type_expr
            {-> New type_expr.array(expr.expr, type_expr.type_expr)}
        | {slice} lsquare rsquare type_expr
            {-> New type_expr.slice(type_expr.type_expr)}
        | {struct} struct lbrace struct_sub_stmt* rbrace
            {-> New type_expr.struct([struct_sub_stmt.type_spec])};

    prim_type {-> type_expr} = 
          {castable} castable_prim_type
            {-> castable_prim_type.type_expr}
        | {string} string
            {-> New type_expr.string()} ;

    castable_prim_type {-> type_expr} = 
          {bool} bool
            {-> New type_expr.bool()}
        | {int} int
            {-> New type_expr.int()}
        | {float} float64
            {-> New type_expr.float()}
        | {rune} rune
            {-> New type_expr.rune()} ;

    struct_sub_stmt {-> type_spec} = id_list type_expr semi
        {-> New type_spec.spec([id_list.id], type_expr)} ;

    //* Expressions. *//

    expr_list {-> expr*} =
          {empty_expr}
            {-> []}
        | {expr} expr
            {-> [expr.expr]}
        | {exprs} expr comma expr_list 
            {-> [expr.expr, expr_list.expr]} ;

    expr {-> expr} =
          {conjunction} conjunction
            {-> conjunction.expr}
        | {or} expr pipe_pipe conjunction 
            {-> New expr.or(expr.expr, conjunction.expr)} ;

    conjunction {-> expr} =
          {clause} clause
            {-> clause.expr}
        | {and} conjunction amp_amp clause 
            {-> New expr.and(conjunction.expr, clause.expr)} ;

    clause {-> expr} =
          {sub_expr} sub_expr
            {-> sub_expr.expr}
        | {eq} clause equals sub_expr
            {-> New expr.eq(clause.expr, sub_expr.expr)}
        | {neq} clause not_equals sub_expr
            {-> New expr.neq(clause.expr, sub_expr.expr)}
        | {lt} clause lt sub_expr
            {-> New expr.lt(clause.expr, sub_expr.expr)}
        | {lte} clause lte sub_expr
            {-> New expr.lte(clause.expr, sub_expr.expr)}
        | {gt} clause gt sub_expr
            {-> New expr.gt(clause.expr, sub_expr.expr)}
        | {gte} clause gte sub_expr 
            {-> New expr.gte(clause.expr, sub_expr.expr)} ;

    sub_expr {-> expr} =
          {factor} factor
            {-> factor.expr}
        | {plus} sub_expr plus factor
            {-> New expr.add(sub_expr.expr, factor.expr)}
        | {minus} sub_expr minus factor
            {-> New expr.subtract(sub_expr.expr, factor.expr)}
        | {bit_or} sub_expr pipe factor
            {-> New expr.bit_or(sub_expr.expr, factor.expr)}
        | {bit_xor} sub_expr carot factor 
            {-> New expr.bit_xor(sub_expr.expr, factor.expr)} ;

    factor {-> expr} =
          {term} term
            {-> term.expr}
        | {mult} factor star term
            {-> New expr.mult(factor.expr, term.expr)}
        | {div} factor slash term
            {-> New expr.div(factor.expr, term.expr)}
        | {mod} factor perc term
            {-> New expr.mod(factor.expr, term.expr)}
        | {bit_lshift} factor lshift term
            {-> New expr.bit_lshift(factor.expr, term.expr)}
        | {bit_rshift} factor rshift term
            {-> New expr.bit_rshift(factor.expr, term.expr)}
        | {bit_and} factor amp term
            {-> New expr.bit_and(factor.expr, term.expr)}
        | {bit_clear} factor amp_carot term 
            {-> New expr.bit_clear(factor.expr, term.expr)} ;

    term {-> expr} =
          {atom} atom
            {-> atom.expr}
        | {pos} plus atom
            {-> New expr.pos(atom.expr)}
        | {neg} minus atom
            {-> New expr.neg(atom.expr)}
        | {not} not atom
            {-> New expr.not(atom.expr)}
        | {bit_comp} carot atom 
            {-> New expr.bit_comp(atom.expr)} ;

    atom {-> expr} =
          {lit} lit
            {-> lit.expr}
        | {id} id
            {-> New expr.variable(id)} 
        | {field} atom dot id
            {-> New expr.field(atom.expr, id)}
        | {func_call} func_call
            {-> func_call.expr}
        | {paren} lparen expr rparen 
           {-> expr.expr};

    func_call {-> expr} = 
          {append} append lparen id comma expr rparen
            {-> New expr.append(id, expr)}
        | {prim_type_cast} castable_prim_type lparen expr rparen
            {-> New expr.prim_type_cast(castable_prim_type.type_expr, expr)}
        | {custom_func_call} id lparen expr_list rparen
            {-> New expr.func_call(id, [expr_list.expr])};

    //* Literals. *//

    lit {-> expr} =
          {bool_lit} bool_lit 
            {-> New expr.bool_lit(bool_lit)}
        | {int_lit} int_lit 
            {-> New expr.int_lit(int_lit)}
        | {oct_lit} oct_lit 
            {-> New expr.oct_lit(oct_lit)}
        | {hex_lit} hex_lit 
            {-> New expr.hex_lit(hex_lit)}
        | {float_lit} float_lit 
            {-> New expr.float_lit(float_lit)}
        | {rune_lit} rune_lit 
            {-> New expr.rune_lit(rune_lit)}
        | {interpreted_string_lit} interpreted_string_lit 
            {-> New expr.interpreted_string_lit(interpreted_string_lit)}
        | {raw_string_lit} raw_string_lit 
            {-> New expr.raw_string_lit(raw_string_lit)};

Abstract Syntax Tree
    prog = {prog} id expr* ;

    top_dec =
          {vars} var_spec*
        | {types} type_spec* ;

    var_spec = {spec} id+ type_expr? expr* ;

    type_spec = {spec} id+ type_expr ;

    type_expr =
          {bool}
        | {int}
        | {float}
        | {rune}
        | {string}
        | {custom} id
        | {array} expr type_expr
        | {slice} type_expr
        | {struct} type_spec* ;

    expr =  
          {bool_lit} bool_lit
        | {int_lit} int_lit
        | {oct_lit} oct_lit
        | {hex_lit} hex_lit 
        | {float_lit} float_lit
        | {rune_lit} rune_lit 
        | {interpreted_string_lit} interpreted_string_lit 
        | {raw_string_lit} raw_string_lit
        | {variable} id
        | {field} expr id
        | {append} id expr
        | {prim_type_cast} type_expr expr
        | {func_call} id expr*
        | {neg} expr
        | {pos} expr
        | {bit_comp} expr
        | {not} expr
        | {mult} [left]:expr [right]:expr
        | {div} [left]:expr [right]:expr
        | {mod} [left]:expr [right]:expr
        | {bit_lshift} [left]:expr [right]:expr
        | {bit_rshift} [left]:expr [right]:expr
        | {bit_and} [left]:expr [right]:expr
        | {bit_clear} [left]:expr [right]:expr
        | {add} [left]:expr [right]:expr
        | {subtract} [left]:expr [right]:expr
        | {bit_or} [left]:expr [right]:expr
        | {bit_xor} [left]:expr [right]:expr
        | {eq} [left]:expr [right]:expr
        | {neq} [left]:expr [right]:expr
        | {lt} [left]:expr [right]:expr
        | {gt} [left]:expr [right]:expr
        | {lte} [left]:expr [right]:expr
        | {gte} [left]:expr [right]:expr
        | {and} [left]:expr [right]:expr
        | {or} [left]:expr [right]:expr ;
