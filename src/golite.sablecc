Package golite ;

Helpers
    // All ASCII characters.
    all = [0 .. 127] ;
    
    // Special whitespace characters.
    tab = 9 ;
    lf = 10 ;
    cr = 13 ;

    not_eol = [all - [cr + lf]] ;

    not_star = [all - '*'] ;
    not_star_slash = [all - ['*' + '/']] ;

    // Digits.
    digit = ['0' .. '9'] ;
    pos_digit = ['1' .. '9'] ;
    oct_digit = ['0' .. '7'] ;
    hex_digit = digit | ['A' .. 'F'] | ['a' .. 'f'] ;

    // Quotes.
    squote = ''' ;
    dquote = '"' ;
    bquote = '`' ;

    // Escaped characters.
    escapes = '\' ('a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\') ;
    escape_squote = '\' ''';
    escape_dquote = '\"';

    alpha = ['A' .. 'Z'] | ['a' .. 'z'] | '_' ;
    alpha_num = alpha | digit ;

Tokens
    /* Go keywords. */
    break = 'break' ;
    case = 'case' ;
    chan = 'chan' ;
    const = 'const' ;
    continue = 'continue' ;
    default = 'default' ;
    defer = 'defer' ;
    else = 'else' ;
    fallthrough = 'fallthrough' ;
    for = 'for' ;
    func = 'func' ;
    go = 'go' ;
    goto = 'goto' ;
    if = 'if' ;
    import = 'import' ;
    interface = 'interface' ;
    map = 'map' ;
    package = 'package' ;
    range = 'range' ;
    return = 'return' ;
    select = 'select' ;
    struct = 'struct' ;
    switch = 'switch' ;
    type = 'type' ;
    var = 'var' ;

    /* GoLite keywords. */
    int = 'int' ;
    float64 = 'float64' ;
    bool = 'bool' ;
    rune = 'rune' ;
    string = 'string' ;
    print = 'print' ;
    println = 'println' ;
    append = 'append' ;

    /*  Operators. */
    plus = '+' ;
    minus = '-' ;
    star = '*' ;
    slash = '/' ;
    perc = '%' ;
    amp = '&' ;
    pipe = '|' ;
    carot = '^';
    lshift = '<<' ;
    rshift = '>>' ;
    amp_carot = '&^' ;
    plus_assign = '+=' ;
    minus_assign = '-=' ;
    star_assign = '*=' ;
    slash_assign = '/=' ;
    perc_assign = '%=' ;
    and_assign = '&=' ;
    pipe_assign = '|=' ;
    carot_assign = '^=' ;
    lshift_assign = '<<=' ;
    rshift_assign = '>>=' ;
    amp_carot_assign = '&^=' ;
    amp_amp = '&&' ;
    pipe_pipe = '||' ;
    arrow = '<-' ;
    plus_plus = '++' ;
    minus_minus = '--' ;
    equals = '==' ;
    lt = '<' ;
    gt = '>' ;
    assign = '=' ;
    not = '!' ;
    not_equals = '!=' ;
    lte = '<=' ;
    gte = '>=' ;
    short_assign = ':=' ;
    ellipsis = '...' ;
    lparen = '(' ;
    rparen = ')' ;
    lsquare = '[' ;
    rsquare = ']' ;
    lbrace = '{' ;
    rbrace = '}' ;
    comma = ',' ;
    semi = ';' ;
    dot = '.' ;
    colon = ':' ;

    // Blank space.
    blank = ' ' | tab ;
    // End-of-line.
    eol = lf | cr | cr lf ;

    // Single-line comment and multi-line comments.
    comment = '//' not_eol* | '/*' ([all - '*'] | '*' [all - '/'])* '*/' ;
    // Alternative form for handling multi-line comments:
    // comment = '//' not_eol* | '/*' '*'* [all - '*']+ '*'+ ([all - ['*' + '/']] [all - '*']* '*'+)* '/' ;

    /* Literals. */

    // Boolean.
    bool_lit = 'true' | 'false' ;

    // Integer.
    int_lit = '0' | pos_digit digit* ;
    oct_lit = '0' oct_digit+ ;
    hex_lit = '0' ['x' + 'X'] hex_digit+ ;

    // Floating-point.
    float_lit = ('0' | pos_digit digit*)? '.' digit* | '.' digit+ ;

    // Rune.
    rune_lit = squote ([not_eol - [squote + '\']] | escape_squote| escapes) squote ;

    // Interpreted string.
    interpreted_string_lit = dquote ([not_eol - [dquote + '\']] | escape_dquote| escapes)* dquote ;

    // Raw string.
    raw_string_lit = bquote [all - bquote]* bquote ;

    /* Identifiers. */
    id = alpha alpha_num* ;

Ignored Tokens
    blank, eol, comment ;

Productions
    // TODO: Fix variable naming.

    /* Program */
    
    prog = {prog} pack_dec top_dec* ;

    /* Package declaration */

    pack_dec = {pack} package id semi ;
    
    /* Top-level declarations */

    top_dec =
          {top_var_dec} top_var_dec
        | {top_type_dec} top_type_dec
        | {top_struct_dec} top_struct_dec
        | {func_dec} func_dec ;

    /* Variable declarations */

    top_var_dec =
          {top_var_stmt} var var_dec semi
        | {top_var_dist_stmt} var lparen var_dist_dec_sub* rparen semi ;

    var_dist_dec_sub = {var_dist_dec_sub} var_dec semi ;

    var_dec =
          {var_dec} id_list val_type
        | {var_dec_init} id_list assign expr_list
        | {var_dec_typed_init} id_list val_type assign expr_list ;
    
    /* Type declarations */

    top_type_dec =
          {top_type_stmt} type type_dec semi
        | {top_type_dist_stmt} type lparen type_dist_dec_sub* rparen semi ;

    type_dist_dec_sub = {type_dist_dec_sub} type_dec semi ;

    type_dec = {type_dec} id val_type ;

    /* Struct declaration */

    top_struct_dec = {top_struct_stmt} struct_dec semi ;

    struct_dec = {struct_dec} type id struct lbrace struct_dec_sub* rbrace ;

    struct_dec_sub = {struct_dec_sub} id_list val_type semi ;

    /* Function declaration */

    func_dec =
          {func_dec_args_rettype} func id lparen args rparen val_type lbrace stmt* rbrace semi
        | {func_dec_args_no_rettype} func id lparen args rparen lbrace stmt* rbrace semi
        | {func_dec_no_args_rettype} func id lparen rparen val_type lbrace stmt* rbrace semi
        | {func_dec_no_args_no_rettype} func id lparen rparen lbrace stmt* rbrace semi ; 
    
    args = {func_args} arg_non_tail* arg_of_type ;

    arg_non_tail = {func_arg_non_tail} arg_of_type comma ;

    arg_of_type = {arg_of_type} id_list val_type ;

    /* Statements */

    stmt =
          {simple_stmt} simple_stmt
        | {var_dec_stmt} top_var_dec
        | {type_dec_stmt} top_type_dec
        | {struct_stmt} top_struct_dec
        | {print_stmt} print lparen expr_list rparen semi
        | {println_stmt} println lparen expr_list rparen semi
        | {return_stmt} return_stmt
        | {if_stmt} if_sent semi
        | {switch_stmt} switch_sent semi
        | {loop_stmt} loop semi
        | {break_stmt} break semi
        | {continue_stmt} continue semi ;

    simple_stmt =
          {expr_stmt} expr semi
        | {incr_decr_stmt} incr_decr semi
        | {assign_stmt} assign_stmt semi
        | {short_dec_stmt} short_dec semi ;

    incr_decr =
          {incr} id plus_plus
        | {decr} id minus_minus ;

    assign_stmt =
          {reg_assign_stmt} assignable_list assign expr_list
        | {op_assign_smt} assignable op_assign expr ; 

    short_dec = {short_dec} id_list short_assign expr_list ;

    op_assign =
          {plus_assign} plus_assign
        | {minus_assign} minus_assign
        | {star_assign} star_assign
        | {slash_assign} slash_assign
        | {perc_assign} perc_assign
        | {and_assign} and_assign
        | {pipe_assign} pipe_assign
        | {carot_assign} carot_assign
        | {lshift_assign} lshift_assign
        | {rshift_assign} rshift_assign
        | {amp_carot_assign} amp_carot_assign ;

    return_stmt = 
          {return} return semi
        | {return_with_exp} return expr semi ;

    if_sent =
          {if} if condition block
        | {if_else} if condition [first]:block else [second]:block
        | {if_elif} if condition block else if_sent ;

    // TODO: Verify
    condition = 
          {condition_expr} expr
        | {condition_init_expr} simple_stmt expr ;

    // TODO: Verify.
    switch_sent =
          {switch_simple_expr} switch simple_stmt expr lbrace case_block* rbrace
        | {switch_simple} switch simple_stmt lbrace case_block* rbrace
        | {switch_expr} switch expr lbrace case_block* rbrace
        | {switch_empty} switch lbrace case_block* rbrace ;

    case_block =
          {case} case expr_list colon stmt*
        | {default} default colon stmt* ;

    // TODO: Verify
    loop =
          {for_loop} for short_dec [first]:semi expr [second]:semi incr_decr block
        | {while_loop} for expr block
        | {inf_loop} for block ;

    block = {block} lbrace stmt* rbrace ;

    /* Identifiers */

    id_list =
          {id} id
        | {cst_ids} id comma id_list ;

    /* Types */

    val_type =
          {reg_type} reg_type
        | {array} lsquare int_lit rbrace val_type
        | {slice} lsquare rsquare val_type ;

    reg_type = 
          {bool} bool
        | {int} int
        | {float} float64
        | {string} string
        | {rune} rune
        | {id} id ;

    /* Expressions */

    expr_list =
          {empty_expr}
        | {expr} expr
        | {cst_exprs} expr comma expr_list ;

    expr =
          {conjunction} conjunction
        | {cst_or}      expr pipe_pipe conjunction ;

    conjunction =
          {clause} clause
        | {cst_and} conjunction amp_amp clause ;

    clause =
          {sub_expr} sub_expr
        | {cst_eq} clause equals sub_expr
        | {cst_neq} clause not_equals sub_expr
        | {cst_lt} clause lt sub_expr
        | {cst_lte} clause lte sub_expr
        | {cst_gt} clause gt sub_expr
        | {cst_gte} clause gte sub_expr ;

    sub_expr =
          {factor} factor
        | {cst_plus} sub_expr plus factor
        | {cst_minus} sub_expr minus factor
        | {cst_bit_or} sub_expr pipe factor
        | {cst_bit_xor} sub_expr carot factor ;

    factor =
          {term} term
        | {cst_mult} factor star term
        | {cst_div} factor slash term
        | {cst_mod} factor perc term
        | {cst_lshift} factor lshift term
        | {cst_rshift} factor rshift term
        | {cst_bit_and} factor amp term
        | {cst_bit_clear} factor amp_carot term ;

    term =
          {atom} atom
        | {cst_pos} plus atom
        | {cst_neg} minus atom
        | {cst_not} not atom
        | {cst_bit_comp} carot atom ;

    atom =
          {lit} lit
        | {id} id
        | {field} field
        | {func_expr} func_expr
        | {paren} lparen expr rparen ;

    func_expr = 
          {append} append lparen expr_list rparen  
        | {int} int lparen expr_list rparen
        | {float64} float64 lparen expr_list rparen
        | {rune} rune lparen expr_list rparen
        | {id} id lparen expr_list rparen ;

    /* Literals */

    lit =
          {bool_lit} bool_lit
        | {int_lit} int_lit
        | {oct_lit} oct_lit
        | {hex_lit} hex_lit
        | {float_lit} float_lit
        | {rune_lit} rune_lit
        | {interpreted_string_lit} interpreted_string_lit
        | {raw_string_lit} raw_string_lit ;

    assignable_list =
          {assignable} assignable
        | {assignables} assignable comma assignable_list ;

    assignable = 
          {id} id
        | {field} field ;

    field = {field} [first]:id dot [second]:id ;
