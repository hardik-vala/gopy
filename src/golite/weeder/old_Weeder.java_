/* This file was generated by SableCC (http://www.sablecc.org/). */

package golite.weeder;

import java.util.*;
import golite.util.*;
import golite.node.*;
import golite.exception.*;
import golite.analysis.*;

public class Weeder extends DepthFirstAdapter
{

    private LineAndPos lineAndPos = new LineAndPos();
    private boolean packageFound = false;
    private boolean inLoop = false;

    //Helper methods
    public void callWeedException(Node node, String s) {
        Integer line = lineAndPos.getLine(node);
        Integer pos = lineAndPos.getPos(node);
        String message = "[" + line + "," + pos + "] " + s;
        WeedException e = new WeedException(message);
        e.printStackTrace();
        System.exit(1);
    }

    @Override //Modified
    public void inStart(Start node)
    {
        node.apply(lineAndPos);
        packageFound = false;
        defaultIn(node);
    }

    @Override //Modified
    public void inAProgProg(AProgProg node)
    {
        if (packageFound) {
            callWeedException(node, "Programs should not have more than one package declaration");
        } else {
            packageFound = true;
        }
        defaultIn(node);
    }

    @Override //Modified
    public void caseAFuncTopDec(AFuncTopDec node)
    {
        inAFuncTopDec(node);
        if(node.getId() != null)
        {
            node.getId().apply(this);
        }
        {
            List<PArgGroup> copy = new ArrayList<PArgGroup>(node.getArgGroup());
            for(PArgGroup e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getTypeExpr() != null)
        {
            List<PStmt> copy = new ArrayList<PStmt>(node.getStmt());
            boolean returnFound = false;
            for (PStmt e: copy)
            {
                if (e instanceof AReturnStmt)
                {
                    returnFound = true;
                }
            }
            if (!returnFound)
            {
                callWeedException(node, "Function signature requires a return statement");
            }
            node.getTypeExpr().apply(this);
        }
        {
            List<PStmt> copy = new ArrayList<PStmt>(node.getStmt());
            for(PStmt e : copy)
            {
                e.apply(this);
            }
        }
        outAFuncTopDec(node);
    }

    @Override //Modified
    public void inASpecVarSpec(ASpecVarSpec node)
    {
        {
            int idLength = (new ArrayList<TId>(node.getId())).size();
            int exprLength = (new ArrayList<PExpr>(node.getExpr())).size();
            if (idLength != exprLength && exprLength > 0)
            {
                callWeedException(node, "Variable specification must include same number of items on left and right of assignment operator");
            }
        }
        defaultIn(node);
    }

    @Override //Modified
    public void inAShortAssignStmt(AShortAssignStmt node)
    {
        {
            int idLength = (new ArrayList<TId>(node.getId())).size();
            int exprLength = (new ArrayList<PExpr>(node.getExpr())).size();
            if (idLength != exprLength && exprLength > 0)
            {
                callWeedException(node, "Short assignment must include same number of items on left and right of assignment operator");
            }
        }
        defaultIn(node);
    }

    @Override //Modified
    public void inAContinueStmt(AContinueStmt node)
    {
        if (!inLoop) {
            callWeedException(node, "Continue statements should only occur in for or while loops");
        }
        defaultIn(node);
    }

    @Override //Modified
    public void inABreakStmt(ABreakStmt node)
    {
        if (!inLoop) {
            callWeedException(node, "Break statements should only occur in for or while loops");
        }
        defaultIn(node);
    }

    @Override //Modified
    public void inASwitchStmt(ASwitchStmt node)
    {
        defaultIn(node);
        boolean containsDefault = false;
        List<PCaseBlock> copy = new ArrayList<PCaseBlock>(node.getCaseBlock());
        for(PCaseBlock e : copy)
        {
            if (((ABlockCaseBlock) e).getCaseCondition() instanceof ADefaultCaseCondition)
            {
                if (containsDefault == true)
                {   
                    callWeedException((ABlockCaseBlock) e, "Switch statements should not have more than one default condition");
                }
                containsDefault = true;
            }
        }
    }

    @Override  //Modified
    public void inAForLoopStmt(AForLoopStmt node)
    {
        inLoop = true;
        defaultIn(node);
    }

    @Override  //Modified
    public void outAForLoopStmt(AForLoopStmt node)
    {
        defaultOut(node);
        inLoop = false;
    }

    @Override //Modified
    public void inAWhileLoopStmt(AWhileLoopStmt node)
    {
        inLoop = true;
        defaultIn(node);
    }

    @Override //Modified
    public void outAWhileLoopStmt(AWhileLoopStmt node)
    {
        defaultOut(node);
        inLoop = false;
    }
}